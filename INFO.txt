## URLs

# Good z-wave info
http://www.cd-jackson.com/index.php/zwave/zwave-device-database/zwave-device-database-guide
http://wiki.linuxmce.org/index.php/ZWave_API
https://github.com/yepher/RaZBerry

# Other implementations
https://github.com/openhab/org.openhab.binding.zwave
https://github.com/oberasoftware/zwave
https://github.com/whizzosoftware/WZWave

## My running notes

====

skicka NAK om checksum inte stämmer.
Cancel == Resend request

Starta om och leta efter SOF om inte längd eller command-type är rimliga.

private const int DEFAULT_TIMEOUT = 10000; // How long in ms to wait for an response
        obs! olika, 5, 10 s.

checka efter publicerade paket! samma som föregående => ignorera.

    TRANSPORT LAYER (serial) => FRAME LAYER (cehcksum, ack/nak) => SESSION LAYER (sequence number, match request/response) => APPLICATION LAYER
obs. APPLICATION LAYER == hålla rätt på noder och nätverkets hälsa, ovanpå detta finns ytterligare ett lager
som typ skickar on/off och läser av statusrapporter från sensorer osv.

Kan motsatsen gälla, att vi får emot request-frames med en sequence???

Sätt timestamp på när vi tar emot framesen.

skillnad på frame och packet? frame är lågnivå, packet själva innehållet?

Ett bra dbus-protokoll ska antagligen supporta flera olika controllers.
gör så här: varje enhet har en adress som är controller:id eller nät:id.

# wait max 5 seconds on reply to request.
# checksum: räkna ut: sätt till 0, gör xor över hela, skriv resultatet
# kolla: räkna xor över hela inkl checksum, då ska det bli 0. el 0xff?
#kallas LRC using XOR.

 * A ZWave serial message frame is made up as follows
 * Byte 0 : SOF (Start of Frame) 0x01
 * Byte 1 : Length of frame - number of bytes to follow
 * Byte 2 : Request (0x00) or Response (0x01)
 * Byte 3 : Message Class (see SerialMessageClass)
 * Byte 4+: Message Class data                             >> Message Payload
 * Byte x : Last byte is checksum

void Controller::PlayInitSequence
(
	Driver* _driver
)
{
	_driver->SendMsg( new Msg( "FUNC_ID_ZW_GET_VERSION", 0xff, REQUEST, FUNC_ID_ZW_GET_VERSION, false ), Driver::MsgQueue_Command );
	_driver->SendMsg( new Msg( "FUNC_ID_ZW_MEMORY_GET_ID", 0xff, REQUEST, FUNC_ID_ZW_MEMORY_GET_ID, false ), Driver::MsgQueue_Command );
	_driver->SendMsg( new Msg( "FUNC_ID_ZW_GET_CONTROLLER_CAPABILITIES", 0xff, REQUEST, FUNC_ID_ZW_GET_CONTROLLER_CAPABILITIES, false ), Driver::MsgQueue_Command );
	_driver->SendMsg( new Msg( "FUNC_ID_SERIAL_API_GET_CAPABILITIES", 0xff, REQUEST, FUNC_ID_SERIAL_API_GET_CAPABILITIES, false ), Driver::MsgQueue_Command );
	_driver->SendMsg( new Msg( "FUNC_ID_ZW_GET_SUC_NODE_ID", 0xff, REQUEST, FUNC_ID_ZW_GET_SUC_NODE_ID, false ), Driver::MsgQueue_Command );
	// FUNC_ID_ZW_GET_VIRTUAL_NODES & FUNC_ID_SERIAL_API_GET_INIT_DATA has moved into the handler for FUNC_ID_SERIAL_API_GET_CAPABILITIES
}
#define FUNC_ID_ZW_MEMORY_GET_ID						0x20
#define FUNC_ID_ZW_GET_CONTROLLER_CAPABILITIES			0x05
#define FUNC_ID_SERIAL_API_GET_CAPABILITIES				0x07
#define FUNC_ID_ZW_GET_SUC_NODE_ID						0x56	// Try to retrieve a Static Update Controller node id (zero if no SUC present)

#define FUNC_ID_ZW_GET_VIRTUAL_NODES					0xA5	// Return all virtual nodes
#define FUNC_ID_SERIAL_API_GET_INIT_DATA				0x02

// at start of communications, send a NAK to resynchronise communications

openzwave installation deps:
libudev-dev

ozwcp:
libmicrohttpd-dev

---

2018-01-13 16:22:28.903 Info, Node001,     COMMAND_CLASS_BASIC is not mapped
2018-01-13 16:22:28.903 Info, Node001,   Mandatory Command Classes for Node 1:
2018-01-13 16:22:28.903 Info, Node001,     None
2018-01-13 16:22:28.903 Info, Node001,   Mandatory Command Classes controlled by Node 1:
2018-01-13 16:22:28.903 Info, Node001,     COMMAND_CLASS_BASIC

2018-01-13 16:22:28.920 Info, Node001, Sending (Command) message (Callback ID=0x00, Expected Reply=0x80) - Get Routing Info (Node=1): 0x01, 0x07, 0x00, 0x80, 0x01, 0x00, 0x00, 0x03, 0x7a
2018-01-13 16:22:28.924 Detail, Node001,   Received: 0x01, 0x20, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e
2018-01-13 16:22:28.924 Detail,
2018-01-13 16:22:28.924 Info, Node001, Received reply to FUNC_ID_ZW_GET_ROUTING_INFO
2018-01-13 16:22:28.924 Info, Node001,     Neighbors of this node are:
2018-01-13 16:22:28.924 Info, Node001,  (none reported)

--

2018-01-13 17:06:37.529 Detail, Node001, Queuing (Command) ControllerCommand_SendNodeInformation (Node=1): 0x01, 0x06, 0x00, 0x12, 0x01, 0x25, 0x0b, 0xc4
2018-01-13 17:06:37.529 Detail, Notification: ControllerCommand - Starting
2018-01-13 17:06:37.529 Info, Notification: ControllerCommand home fbe39bfd Event 1 Error 0
2018-01-13 17:06:37.529 Detail,
2018-01-13 17:06:37.529 Info, Node001, Sending (Command) message (Callback ID=0x0b, Expected Reply=0x12) - ControllerCommand_SendNodeInformation (Node=1): 0x01, 0x06, 0x00, 0x12, 0x01, 0x25, 0x0b, 0xc4
2018-01-13 17:06:37.538 Detail, Node001,   Received: 0x01, 0x04, 0x01, 0x12, 0x01, 0xe9
2018-01-13 17:06:37.538 Detail,
2018-01-13 17:06:37.538 Info, **TODO: handle response for 0x12** Please report this message.
2018-01-13 17:06:38.067 Detail, Node001,   Received: 0x01, 0x05, 0x00, 0x12, 0x0b, 0x01, 0xe2
2018-01-13 17:06:38.067 Detail,

FUNC_ID_APPLICATION_COMMAND_HANDLER - antar att det är den som prefixar alla paket unsolicited paket?
	uint8 status = _data[2];
	uint8 nodeId = _data[3];
 data[4] = len

	uint8 classId = _data[5];
	data[6] = actual data.
	 -- of this, [0] is cmd value
	if( ( status & RECEIVE_STATUS_ROUTED_BUSY ) != 0 )
	{
		m_routedbusy++;
	}
	if( ( status & RECEIVE_STATUS_TYPE_BROAD ) != 0 )
	{
		m_broadcastReadCnt++;
	}
		int cmp = memcmp( _data, node->m_lastReceivedMessage, sizeof(node->m_lastReceivedMessage));
		if( cmp == 0 && node->m_receivedTS.TimeRemaining() > -500 )
		{
			// if the exact same sequence of bytes are received within 500ms
			node->m_receivedDups++;
		}
		if( m_expectedReply == FUNC_ID_APPLICATION_COMMAND_HANDLER && m_expectedNodeId == nodeId )
		{
			// Need to confirm this is the correct response to the last sent request.
			// At least ignore any received messages prior to the send data request.
			node->m_lastResponseRTT = -node->m_sentTS.TimeRemaining();
		}
		else
		{
			node->m_receivedUnsolicited++;
		}

...
	else if( ControllerReplication::StaticGetCommandClassId() == classId )
	{
			m_controllerReplication->HandleMsg( &_data[6], _data[4] );

	if( CommandClass* pCommandClass = GetCommandClass( _data[5] ) )


	// See if there is already a copy of this message in the queue.  If so,
	// we delete it.  This is to prevent duplicates building up if the
	// device does not wake up very often.  Deleting the original and
	// adding the copy to the end avoids problems with the order of
	// commands such as on and off.
